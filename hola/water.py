######################################################################
#
# HOLA == Human-like Orthogonal Layout Algorithm
# This file is part of HOLA.
#
# Copyright (C) 2014-2015  Steve Kieffer
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA  02110-1301, USA.
#
#
# Author: Steve Kieffer  <http://skieffer.info>
#
######################################################################

from logging import LogLevel
from ortho import *
from constraints import SepCo
import adaptagrams.adaptagrams as adg
import sys
import inspect

class WaterDivide:
    """
    An instance of this class is meant to manage the combination of all the
    possible ways to generate nonoverlap constraints in one dimension, when
    making room for a TreePlacement, and using the idea of a "water divide."

    The idea is that we choose strategic "goal points" in the face, and ask
    libavoid to find orthogonal routes between these points. We can then use
    these routes to determine the nonoverlap constraints by pushing everything
    on one side of the route to one side, and everything on the other side of
    the route to the other side...much as the water on different sides of a
    continental water divide flows into different oceans.

    A TreePlacement contains both a "placement direction" dp, and a "growth
    direction" dg. The former is any compass point, cardinal or ordinal, while
    the latter must be cardinal. The WaterDivide object is said to operate
    "axially" if it generates constraints in the dimension to which dg belongs,
    and to operate "transversely" if it generates constraints in the complementary
    dimension. For example if dg is NORTH, then SepCo's in the y-dim are axial,
    while those in the x-dim are transverse.

    If the placement direction dp is cardinal, then an axial water divide has
    precisely one goal point, while a transverse water divide has precisely two
    goal points. If dp is ordinal then there is precisely one goal point in both
    the axial and the transverse dimensions.

    For each goal point the WaterDivide object constructs a WaterGoal object,
    which in turn constructs one or more WaterLevel objects; see the doc text
    for those classes for more information.
    """

    def __init__(self, tp, primaryDim, iel, logger):
        """
        :param tp: a TreePlacement object
        :param primaryDim: the primary dimension in which to generate sepcos
        :param iel: ideal edge length for the graph
        """
        self.tp = tp
        self.primaryDim = primaryDim
        self.iel = iel
        self.logger = logger
        # A counter, to enumerate all goals:
        self.goalCounter = 0
        # Compute the goals, first in the primary dimension...
        self.goals = self.computeGoals(primaryDim, iel)
        # ...then extend with the goals in the complementary dimension.
        self.goals.extend(self.computeGoals(1 - primaryDim, iel))

    def estimateCost(self, use_old_heuristic=False):
        xEst, yEst = self.estimateCostByDimension(use_old_heuristic=use_old_heuristic)
        return xEst + yEst

    def estimateCostByDimension(self, use_old_heuristic=False):
        if use_old_heuristic:
            return self.estimateCostByDimension_old_method()
        else:
            return self.estimateCostByDimension_new_method()

    def estimateCostByDimension_old_method(self):
        # Compute the existing space in each dimension at Level 0.
        # First partition the goals by the dimension they're working in.
        xGoals, yGoals = [], []
        for goal in self.goals:
            if goal.dim == adg.XDIM:
                # goal.dim is the dimension in which the constraints generated by the
                # goal are to operate; so if its dim is XDIM then its Level 0 goal
                # point represents space in the Y dimension, not X.
                yGoals.append(goal)
            else:
                xGoals.append(goal)
        # Now compute the Level 0 space available in each dimension.
        xLev0, yLev0 = 0, 0
        for goal in xGoals:
            lev0 = goal.computeLevels()[0]
            p1, p0 = lev0.localGoalPt, lev0.basept
            xLev0 += abs(p1[0] - p0[0])
        for goal in yGoals:
            lev0 = goal.computeLevels()[0]
            p1, p0 = lev0.localGoalPt, lev0.basept
            yLev0 += abs(p1[1] - p0[1])
        # Get the tree box.
        w, h, u, v = self.tp.treeBoxWithRootVector(iel=self.iel)
        # Now compute an estimate of the stress involved in expanding the face
        # to make room for the treebox.
        xEst, yEst = 0, 0
        if w > xLev0:
            xEst = (w/float(xLev0) - 1)**2
        if h > yLev0:
            yEst += (h/float(yLev0) - 1)**2
        return (xEst, yEst)

    def estimateCostByDimension_new_method(self):
        cost_by_direc = self.estimateCostByDirection()
        xEst = cost_by_direc[Compass.WEST] + cost_by_direc[Compass.EAST]
        yEst = cost_by_direc[Compass.NORTH] + cost_by_direc[Compass.SOUTH]
        return (xEst, yEst)

    def estimateCostByDirection(self):
        # Prepare the return value.
        costs = {
            Compass.EAST: 0, Compass.SOUTH: 0, Compass.WEST: 0, Compass.NORTH: 0
        }
        # First we consider collateral expansion constraints, if any.
        PSes = self.tp.face.getCollateralProjSeqs(self.tp, self.iel)
        if len(PSes) != 1:
            raise Exception('Did not get unique collateral projseq.')
        ps0 = PSes[0]
        # For each direction in which these constraints act (relative to
        # the root node of our TreePlacement), we want to know the maximum
        # amount of violation in that direction. We set this as the cost in
        # that direction.
        collateral_direcs = set()  # Want to keep track of direcs addressed by collat. expansion
        root = self.tp.node
        C = ps0.getAllConstraints()
        for c in C:
            d = c.getDirectionRelativeToNode(root)
            collateral_direcs.add(d)
            v = c.violation()
            costs[d] = max(costs[d], v)
        # Now we also want to consider any of our goal segments that are in
        # a direction other than one already addressed by collateral expansion
        # (if any). The idea is that, as an estimate, we will guess that colatteral
        # expansion will already buy enough room, in any direction in which it acts.
        for g in self.goals:
            d = g.direc
            if d not in collateral_direcs:
                # In such a case we base our estimate on a comparison of the goal segment
                # against the available space (i.e. the "contained segment").
                # However, since the collateral expansion has only been /described/ (by the
                # necessary constraints), and not actually /performed/, we need to ignore
                # collateral tree boxes. This is because those tree boxes might currently
                # obstruct the contained segment, giving a misrepresentation of the space
                # that would likely become available were the collateral expansion
                # actually to be performed. Therefore we set the appropriate kwarg in
                # this function call:
                cs = g.computeContainedSegment(ignoreCollateralTreeBoxes=True)
                sh = cs.measureShortage()
                costs[d] = sh
        # Done.
        return costs

    def buildProjSeqs(self, ps0, estimate=False):
        """
        :param ps0: an initial ProjSeq object
        :param iel: ideal edge length for the graph
        :return: a list of ProjSeqs extending ps0, each of which suffices on its own
                 to expand the face for the TreePlacement self.tp, and each of which
                 contains evaluated stress changes
        """
        g0 = self.goals[0]
        grem = self.goals[1:]
        if estimate:
            pses = g0.estimateAllLevelsRec(ps0, grem)
        else:
            pses = g0.tryAllLevelsRec(ps0, grem)
        # Reset each projseq, so that it can be applied again, if desired.
        for ps in pses:
            ps.reset()
        return pses

    def isAxial(self, dim):
        return dim == Compass.variableDimension[self.tp.growthDirec]

    def isTransverse(self, dim):
        return dim == Compass.constantDimension[self.tp.growthDirec]

    def computeGoals(self, dim, iel):
        """
        :param dim: a dimension, XDIM or YDIM
        :param iel: ideal edge length for the graph
        :return: list of WaterGoal objects

        Determine what are the main "goal points" for routing in the given dimension.
        There will be either 1 or 2 points, and we represent each by
        a WaterGoal object.
        """
        goals = []
        pdir = self.tp.placementDirec
        grdir = self.tp.growthDirec
        assert(grdir in Compass.cwCards)
        # a function to add a goal in a direction:
        def addGoalInDirec(direc):
            wg = WaterGoal(self.tp, direc, iel, self.logger)
            wg.ID = self.goalCounter
            self.goalCounter += 1
            goals.append(wg)
        if self.isTransverse(dim):
            addGoalInDirec(grdir)
        else:
            assert(self.isAxial(dim))
            if pdir in Compass.cwCards:
                # Cardinal placement direction
                # Need two goal points for axial sepcos, one in each direction.
                cwdir, acwdir = Compass.cw90(grdir), Compass.acw90(grdir)
                addGoalInDirec(acwdir)
                addGoalInDirec(cwdir)
            else:
                assert(pdir in Compass.cwOrds)
                # Ordinal placement direction
                # Need just one goal point for axial sepcos, in the direction which
                # is the complement of the growth dir, w.r.t. the placement dir.
                compdir = filter(lambda d: d != grdir, Compass.components[pdir])[0]
                addGoalInDirec(compdir)
        return goals


class WaterGoal:
    """
    An instance of this class manages a single "major goal point" for the "water
    divide" strategy for producing face expansion constraints.

    Along with the goal point the init method is passed a "base point". It is
    determined where the "major goal segment" -- which runs from the base point
    to the major goal point -- crosses the interior boundary of the Face in
    question, and some of these crossing points become "minor goal points,"
    possibly along with the given major goal point itself, depending on whether
    that point lies inside the face.

    The WaterGoal object constructs a WaterLevel object to manage each minor
    goal point.
    """

    def __init__(self, tp, direc, iel, logger):
        """
        :param tp: the TreePlacement object
        :param direc: the Compass direction in which this goal is working
        :param iel: ideal edge length for the graph
        """
        self.tp = tp
        self.direc = direc
        self.iel = iel
        self.logger = logger
        self.ID = None
        # the dimension in which the generated sepcos are to operate:
        self.dim = Compass.constantDimension[self.direc]

    def pushNodePoses(self):
        self.tp.face.graph.pushNodePoses()

    def popNodePoses(self):
        self.tp.face.graph.popNodePoses()

    def dropNodePoses(self):
        self.tp.face.graph.dropNodePoses()

    def tryAllLevelsRec(self, ps0, grem):
        """
        :param ps0: an initial ProjSeq object
        :param grem: list of remaining WaterGoals
        :return: list of new ProjSeq objects, being all the ways to complete
                 the given one
        """
        logger = self.logger
        # Prepare return list
        pses = []
        # Compute the levels and iterate over them.
        if logger.level >= LogLevel.TIMING:
            logger.startNewTimer('compute_levels')
        levels = self.computeLevels()
        if logger.level >= LogLevel.TIMING:
            logger.stopLastTimer()
        self.pushNodePoses()
        if logger.level >= LogLevel.TIMING:
            suffix = logger.lastSuffix
        for lev in levels:
            if self.tp.face.config.WATER_LEVEL_ZERO_ONLY and lev.idx > 0: continue
            self.popNodePoses()
            self.pushNodePoses()
            if logger.level >= LogLevel.TIMING:
                logger.lastSuffix = suffix
            ps1 = ps0.copy()
            try:
                lev.extendProjSeq(ps1)
            except UnusableWaterPath as uwp:
                if lev.idx > 0:
                    continue
                else:
                    # Level 0 should always be usable.
                    msg = "Unusable Level 0!"
                    msg += '\nRaised at lineno: %s' % uwp.lineNo
                    raise Exception(msg)
            if len(grem) == 0:
                pses.append(ps1)
                if logger.level >= LogLevel.PROGRESS and logger.level < LogLevel.DEBUG:
                    sys.stdout.write('.')
            else:
                g0 = grem[0]
                grem = grem[1:]
                pses.extend(g0.tryAllLevelsRec(ps1, grem))
        self.dropNodePoses()
        # Since we believe that Level 0 is always usable, we put an assertion here:
        assert(len(pses) > 0)
        if logger.level >= LogLevel.DEBUG:
            for ps in pses:
                print 'Cost for %s:\n    %.2f  (%s)' % (
                    suffix, ps.getTotalStressChange(), ps.dSes
                )
        return pses

    def estimateAllLevelsRec(self, ps0, grem):
        """
        :param ps0: an initial ProjSeq object
        :param grem: list of remaining WaterGoals
        :return: list of new ProjSeq objects, being all the ways to complete
                 the given one
        """
        logger = self.logger
        # Prepare return list
        pses = []
        # Compute the levels and iterate over them.
        if logger.level >= LogLevel.TIMING:
            logger.startNewTimer('compute_levels')
        levels = self.computeLevels()
        if logger.level >= LogLevel.TIMING:
            logger.stopLastTimer()
        if logger.level >= LogLevel.TIMING:
            suffix = logger.lastSuffix
        for lev in levels:
            if self.tp.face.config.WATER_LEVEL_ZERO_ONLY and lev.idx > 0: continue
            if logger.level >= LogLevel.TIMING:
                logger.lastSuffix = suffix
            ps1 = ps0.copy()
            try:
                lev.extendProjSeq(ps1, estimate=True)
            except UnusableWaterPath:
                if lev.idx > 0:
                    continue
                else:
                    # Level 0 should always be usable.
                    raise Exception("Unusable Level 0!")
            if len(grem) == 0:
                pses.append(ps1)
                if logger.level >= LogLevel.PROGRESS and logger.level < LogLevel.DEBUG:
                    sys.stdout.write('.')
            else:
                g0 = grem[0]
                grem = grem[1:]
                pses.extend(g0.estimateAllLevelsRec(ps1, grem))
        # Since we believe that Level 0 is always usable, we put an assertion here:
        assert(len(pses) > 0)
        if logger.level >= LogLevel.DEBUG:
            for ps in pses:
                print 'Cost for %s:\n    %.2f  (%s)' % (
                    suffix, ps.getTotalStressChange(), ps.dSes
                )
        return pses

    def computeGoalSegment(self):
        """
        :return: ((bx, by), (gx, gy)) being the base pt and goal pt
        """
        pdir = self.tp.placementDirec
        # base point on the boundary of the root node:
        bX, bY = self.tp.node.getBdryCompassPt(pdir)
        # dimensions of tree box and relation to root centre:
        w, h, u, v = self.tp.treeBoxWithRootVector(iel=self.iel)
        # centre coords of root node:
        rx, ry = self.tp.node.x, self.tp.node.y
        # extreme coords of tree box:
        x, X, y, Y = rx+u-w/2.0, rx+u+w/2.0, ry+v-h/2.0, ry+v+h/2.0
        # possible goal coordinates, by sign relative to base pt:
        gx = {-1: x, 0: bX, 1: X}
        gy = {-1: y, 0: bY, 1: Y}
        sgnx, sgny = Compass.vectorSigns(self.direc)
        return ((bX, bY), (gx[sgnx], gy[sgny]))

    def computeLevels(self):
        """
        We compute the WaterLevel objects representing all the possible "levels" to
        which we might go, in attempting to reach the goal point represented by this
        WaterGoal object.
        :return: nothing
        """
        logger = self.logger
        # Get the list of all line segments which make up the interior boundary of
        # the Face of the TreePlacement.
        if logger.level >= LogLevel.TIMING:
            logger.startNewTimer('bdry_segments')
        bsegs = self.tp.face.computeBoundarySegments(self.iel)
        if logger.level >= LogLevel.TIMING:
            logger.stopLastTimer()
        # Let:
        p0, p1 = self.computeGoalSegment()
        # Now we must determine all the points at which the "goal segment," i.e. the
        # line segment from p0 to p1, crosses the boundary of the Face.
        # Compute the direction from p0 to p1.
        direc = Compass.cardinalDirection(p0, p1)
        # Get the constant coord and extreme coords
        x0, y0 = p0
        x1, y1 = p1
        if direc in Compass.vertical:
            z, w0, w1 = x0, y0, y1
        else:
            z, w0, w1 = y0, x0, x1
        # Filter out the boundary segs that are not transverse to the goal segment.
        # It cannot cross any of these. It can overlap them, but that is not how
        # crossings are found.
        bsegs = filter(lambda s: s.isTransverseTo(direc), bsegs)
        # Filter out the remaining boundary segments which do not represent an actual
        # crossing of the Face boundary at the constant coord of the goal segment.
        # This can be either because
        # the closed interval of the boundary segment does not include the constant
        # coord of the goal segment, or because it /is/ included but is /not/ an
        # actual crossing point, as indicated by the crossing booleans
        # stored in the BoundarySegment object.
        bsegs = filter(lambda s: s.canCrossBoundaryAt(z), bsegs)
        # Filter out any segs that are not on the same side of p0 as p1 is.
        sameside_as_p1 = (lambda w: w > w0) if w1 > w0 else (lambda w: w < w0)
        bsegs = filter(lambda s: sameside_as_p1(s.getConstCoord()), bsegs)
        # Sort the remaining segs by their constant coord, in order from p0 to p1.
        bsegs.sort(reverse=(w1 < w0))
        # Form the list of those segs that are on the same side of p1 as p0 is.
        # These are the boundary segments at which the goal segment actually
        # does cross the interior boundary of the Face. Segments which it merely
        # touches without crossing are /not/ included.
        sameside_as_p0 = (lambda w: w > w1) if w0 > w1 else (lambda w: w < w1)
        crossedSegs = filter(lambda s: sameside_as_p0(s.getConstCoord()), bsegs)
        # The list of crossing points:
        pts = [s.getCrossingAt(z) for s in crossedSegs]
        # Now we assemble the list of goal points.
        # First append p1 to the list of points.
        pts.append(p1)
        # Now, if we have crossed the boundary an odd number of times (meaning we
        # wind up outside the face) and if it is possible to cross it again, then
        # tack on one more crossing.
        nb, nc = len(bsegs), len(crossedSegs)
        if nc % 2 == 1 and nb > nc:
            pts.append(bsegs[nc].getCrossingAt(z))
        # Finally, the goal points we want are those with even index in this list
        # of points. (I don't see an easy way to explain /why/ those are the points
        # we want -- you just have to consider all five cases and see that it works;
        # namely, the five cases are determined by the following questions: (1) is
        # the face an internal face or the external face; (2) did we cross an even
        # or odd number of times; (3) if internal and odd, are there any more possible
        # crossings (if external and odd then there MUST be another crossing, since all
        # interior faces are bounded).)
        goalPts = [pts[i] for i in range(0, len(pts), 2)]
        # Form the WaterLevel objects and return them.
        return [WaterLevel(i, p0, g, p1, self, logger) for i, g in enumerate(goalPts)]

    def computeContainedSegment(self, ignoreCollateralTreeBoxes=False):
        """
        We compute the "contained segment", which is the local goal segment for Level 0.

        :param ignoreCollateralTreeBoxes: This is useful when we are interested in
                                          computing estimates of expansion costs.
                                          At such times, we want to guess how long the
                                          contained segment might be once any collateral
                                          tree boxes have been moved away (but without
                                          actually doing the moving).
        :return: nothing
        """
        facing_direc = Compass.flip(self.direc)
        cl, op = self.tp.face.findBoundaryIntervalsFacingOneDirection(
            facing_direc,
            ignoreCollateralTreeBoxesForPlacement = self.tp if ignoreCollateralTreeBoxes else None
        )
        # Let:
        p0, p1 = self.computeGoalSegment()
        # Get the constant coord and extreme coords
        x0, y0 = p0
        x1, y1 = p1
        if self.direc in Compass.vertical:
            z, w0, w1 = x0, y0, y1
        else:
            z, w0, w1 = y0, x0, x1
        # Build list of boundary segments that contain the goal segment's constant coord.
        segs = filter(lambda ls: ls.closedIntervalIncludesCoord(z), cl)
        segs.extend(filter(lambda ls: ls.openIntervalIncludesCoord(z), op))
        # Now suppose p2 is the point on the line segment (p0, p1) farthest from p0 but
        # still inside the face. Then, for some w2 between w0 and w1, we have either p2 = (z, w2)
        # (for vertical goal segs) or p2 = (w2, z) (for horizontal goal segs).
        # Our goal now is to compute w2.
        # We initialize w2 to equal w1.
        w2 = w1
        d2 = abs(w2 - w0)
        e1 = w1 - w0
        # Then we look through the boundary segments and consider each one's constant coord wb.
        # If wb is on the same side of w0 as w1 is, and if wb is closer to w0 than w2 is, this
        # represents the nearest crossing found so far. So we set w2 = wb.
        for seg in segs:
            wb = seg.constCoord()
            eb = wb - w0
            if eb * e1 <= 0:
                # eb * e1 == 0 means eb == 0, i.e. we're considering a boundary segment that
                # actually crosses through the base point. We don't want to consider those.
                # eb * e1 < 0 means we're on the wrong side of the base point.
                continue
            db = abs(eb)
            if db < d2:
                w2 = wb
                d2 = db
        # Having considered all possible crossing segments, we have found the contained segment.
        localGoalPt = (z, w2) if self.direc in Compass.vertical else (w2, z)
        cs = ContainedSegment(p0, localGoalPt, p1, self)
        return cs


class UnusableWaterPath(Exception):

    def __init__(self, wlev, lineNo=None):
        self.wlev = wlev
        self.lineNo = lineNo

    def __repr__(self):
        s = 'Unusable water path from %s to %s' % (
            self.wlev.basept, self.wlev.goalpt
        )
        if self.lineNo is not None:
            s += '\nRaised at water.py line %d.' % self.lineNo
        return s

class NoCorrespondingLevel(Exception):

    def __init__(self, wlev):
        self.wlev = wlev

    def __repr__(self):
        return 'Lost corresponding level for level %d of %d.' % (
            self.wlev.idx, self.wlev.fullNum
        )

class WaterLevel:
    """
    An instance of this class manages a single "minor goal point" for the "water
    divide" strategy for producing face expansion constraints.

    It uses libavoid to compute an orthogonal route from the base point to the
    minor goal point, and then uses the route to generate constraints.
    """

    # Will we try to use negative paths?
    TRY_NEGATIVE_PATHS = True

    def __init__(self, idx, basept, localGoalPt, globalGoalPt, wg, logger):
        # the index of this level in among all the levels computed at the same time:
        self.idx = idx
        # coords (x, y) at beginning of goal segment:
        self.basept = basept
        # coords (x, y) at end of goal segment for routing:
        self.localGoalPt = localGoalPt
        # coords (x, y) at end of segment representing space needed by treebox:
        self.globalGoalPt = globalGoalPt
        self.formSegments()
        # the owning WaterGoal object:
        self.wg = wg
        # logger:
        self.logger = logger
        # ideal edge length for the graph:
        self.iel = wg.iel
        # the TreePlacement object:
        self.tp = wg.tp
        # the dimension in which the generated sepcos are to operate:
        self.dim = wg.dim

    def formSegments(self):
        # segment representing space to be spanned by the route:
        self.localGoalSeg = LineSegment(self.basept, self.localGoalPt)
        # segment representing space needed by treebox:
        self.globalGoalSeg = LineSegment(self.basept, self.globalGoalPt)

    def recomputeGeometry(self):
        """
        This is to be used in the process of attempting
        to straighten out a non-positive path. Since each step of the straightening
        process involves a projection, the geometry of the graph can change. In that
        case, the levels need to be recomputed and we can only proceed to try to
        use "this level" if we have some mapping from the new levels back to the old
        ones. In a strict sense, /this/ level no longer exists at all.

        With the hope in mind that there will often be sufficient stability in the
        graph through the straightening projections, we use the obvious mapping when
        possible; namely, if this object represents level k of n levels, and if after
        recomputing the geometry there still /is/ a level k, then we assume that that
        level corresponds to this one, and we adopt its geometry. If there isn't any
        level k anymore, then we raise a NoCorrespondingLevel exception.

        :return: nothing
        """
        levels = self.wg.computeLevels()
        if not self.idx < len(levels):
            raise NoCorrespondingLevel(self)
        else:
            lev = levels[self.idx]
            self.basept = lev.basept
            self.localGoalPt = lev.localGoalPt
            self.globalGoalPt = lev.globalGoalPt
            self.formSegments()

    def extendProjSeq(self, ps0, estimate=False):
        """
        :param ps0: an initial ProjSeq
        :return: nothing

        We extend the given ProjSeq to expand the face for the minor goal
        represented by this WaterLevel object, or raise an UnusableWaterPath
        exception if we cannot do it.
        """
        logger = self.logger
        wp = self.routeWaterPath()
        # If the path is not /positive/, we need to make it so, or die trying.
        if not wp.positive:
            # Are we actually going to try?
            if WaterLevel.TRY_NEGATIVE_PATHS:
                try:
                    if logger.level >= LogLevel.TIMING:
                        logger.startNewTimer('make_positive_path')
                    wp = self.makePositivePath(wp, ps0)
                except Exception as e:
                    if logger.level >= LogLevel.TIMING:
                        logger.stopLastTimer()
                    raise e
            else:
                raise UnusableWaterPath(self, lineNo=inspect.getframeinfo(inspect.currentframe()).lineno)
        # Now we can try to make room for the tree node.
        self.makeRoomForTreeNode(wp, ps0, estimate=estimate)

    def routeWaterPath(self):
        """
        :return: a WaterPath representing the route libavoid finds between the
                 basept and localGoalPt, for the current shape of the Face
        """
        logger = self.logger
        if self.idx > 0 or logger.level >= LogLevel.DEBUG:
            if logger.level >= LogLevel.TIMING:
                suffix = logger.lastSuffix
                suffix += '_%s%d' % (
                    {Compass.EAST: 'X', Compass.SOUTH: 'Y',
                     Compass.WEST: 'x', Compass.NORTH: 'y'}[self.wg.direc],
                    self.idx
                )
                if logger.level >= LogLevel.PROGRESS:
                    print suffix
                logger.startNewTimer('routing')
            # Get basic routing rig for the face.
            if logger.level >= LogLevel.TIMING:
                logger.startNewTimer('build_obstacles')
            rr = self.tp.face.buildOrthoRoutingRigForSolidifiedFace(self.iel)
            if logger.level >= LogLevel.TIMING:
                logger.stopLastTimer()
            # Add the goal segment, and compute the routing.
            # We set the visibility for the goal point to be in all directions
            # /except/ looking directly back toward the base point.
            forward = self.wg.direc
            backward = Compass.flip(forward)
            backConn = Compass.libavoidVisibility[backward]
            cd1 = adg.ConnDirAll ^ backConn
            cr = rr.addConnectedPts(self.basept, self.localGoalPt, cd1=cd1)
            if logger.level >= LogLevel.TIMING:
                logger.startNewTimer('router')
            rr.route()
            if logger.level >= LogLevel.TIMING:
                logger.stopLastTimer()
            if logger.level >= LogLevel.TIMING:
                logger.stopLastTimer()
            if logger.level >= LogLevel.FINER_STAGE_GRAPHS:
                logger.writeRouterSVG(rr.router, suffix)
            pts = rr.getPtsFromConnRef(cr)
            # The route for a positive level should always have one or more bend points.
            if len(pts) < 3 and self.idx > 0:
                rr.router.outputInstanceToSVG('testOut/waterDivide/routing/posLevNoBends')
                msg = "Error: Positive water level route has no bends"
                action = self.wg.tp.face.config.ON_POSITIVE_WATER_LEVEL_ROUTE_WITHOUT_BENDS
                if action == 0:
                    raise Exception(msg)
                elif action == 1:
                    sys.stderr.write(msg+'\n')
                    raise UnusableWaterPath(self)
                elif action == 2:
                    sys.stderr.write(msg+'\n')
                elif action == 3:
                    pass
            if logger.level >= LogLevel.PROGRESS and logger.level < LogLevel.DEBUG:
                sys.stdout.write('(%d)'%len(pts))
        else:
            pts = [self.basept, self.localGoalPt]
        # Form into a WaterPath object.
        wp = WaterPath(pts, self)
        return wp

    def makeRoomForTreeNode(self, wp, ps0, estimate=False):
        """
        :param wp: a WaterPath object
        :param ps0: an initial ProjSeq
        :return: nothing

        We attempt to extend the given ProjSeq so as to make room in the Face for
        the desired TreePlacement. If any of the projections is infeasible then
        we raise an UnusableWaterPath exception.

        NOTE: keyword 'estimate' is not used because I aborted the attempt. I don't think it
        is actually possible to do an estimate in this way because, e.g., if you are working
        in the x-dimension first then you don't even know what the y-constraints should be until
        you have actually tried the projection in the x-dimension. So I don't think there is any
        way to compute a projection sequence without trying it out as you go.
        """
        logger = self.logger
        assert(wp.positive)
        pcs = []
        # Get the root node of the TreePlacement
        root = self.tp.node
        # Sides
        # We can only work with obstacles that lie opposite the /local/ goal seg.
        sides = self.tp.face.getAllSidesOppositeSegment(self.localGoalSeg, openInterval=True)
        for side in sides:
            # If the root node lies on the Side, need no constraints.
            if side.containsNode(root): continue
            pt = side.getFirstPtOppositeSegment(self.localGoalSeg)
            sign = wp.ptOnWhichSide(pt)
            assert(sign in [-1, 1])
            # The local goal segment can be shorter /or longer/ than the global one (it's longer in
            # cases where we extend the list of crossing points to include the /next/ crossing).
            # We need the half-width of the Side opposite the longer of the two segments.
            lseg, gseg = self.localGoalSeg, self.globalGoalSeg
            longestSeg = lseg if lseg.length > gseg.length else gseg
            sideHW = side.halfwidthOppositeSegment(1 - sign, longestSeg)
            someNode = side.firstNode()  # just need any Node on the Side
            left, right = (someNode, root) if sign == -1 else (root, someNode)
            w, h, u, v = self.tp.treeBoxWithRootVector(iel=self.iel)
            if self.globalGoalSeg.direc in Compass.vertical:
                gap = sideHW + w/2.0 + sign*u
            else:
                gap = sideHW + h/2.0 + sign*v
            gap = max(gap, 0)
            sepco = SepCo(self.dim, left, right, gap)
            pcs.append(sepco)
        # Treenodes
        alltps = self.tp.face.getAllTreePlacements()
        for tp1 in alltps:
            # Check whether the /unpadded/ treenode lies opposite the segment:
            pt = tp1.somePointOppositeSegment(self.localGoalSeg, iel=0, openInterval=True)
            if pt is not None:
                sign = wp.ptOnWhichSide(pt)
                assert(sign in [-1, 1])
                # For computing the gap for the sepco, use the actual box node, which
                # /does/ include padding:
                tn = tp1.boxNode
                left, right = (tn, root) if sign == -1 else (root, tn)
                # And use the /padded/ version of the treenode that is to be added:
                w, h, u, v = self.tp.treeBoxWithRootVector(iel=self.iel)
                if self.globalGoalSeg.direc in Compass.vertical:
                    gap = tn.w/2.0 + w/2.0 + sign*u
                else:
                    gap = tn.h/2.0 + h/2.0 + sign*v
                gap = max(gap, 0)
                sepco = SepCo(self.dim, left, right, gap)
                pcs.append(sepco)
        ps0.addConstraintSet(pcs, self.dim)
        if logger.level >= LogLevel.TIMING:
            suffix = logger.lastSuffix
            suffix += '_%s%d' % (
                {Compass.EAST: 'X', Compass.SOUTH: 'Y',
                 Compass.WEST: 'x', Compass.NORTH: 'y'}[self.wg.direc],
                self.idx
            )
            logger.startNewTimer('projection')
        feasible = self.tp.face.applyPS(ps0, self.iel)
        if logger.level >= LogLevel.TIMING:
            logger.stopLastTimer()
        if not feasible:
            if logger.level >= LogLevel.DEBUG:
                print 'Infeasible projseq for: %s' % suffix
                print repr(ps0)
            raise UnusableWaterPath(self, lineNo=inspect.getframeinfo(inspect.currentframe()).lineno)
        elif logger.level >= LogLevel.FINER_STAGE_GRAPHS:
            logger.writeGML(suffix)

    def makePositivePath(self, wp, ps0):
        """
        :param wp: a WaterPath object
        :param ps0: an initial ProjSeq
        :return: a new WaterPath object whose path is positive, if possible;
                 we raise an UnusableWaterPath exception if we cannot do it
        """
        # Put some upper limit on the number of segments we will try to collapse.
        MAX_SEGMENTS = 10
        n0 = wp.numSegs()
        if n0 > MAX_SEGMENTS:
            raise UnusableWaterPath(self, lineNo=inspect.getframeinfo(inspect.currentframe()).lineno)
        while not wp.positive:
            wp.collapseOneSegment(ps0, self.iel)
            try:
                self.recomputeGeometry()
            except NoCorrespondingLevel:
                raise UnusableWaterPath(self, lineNo=inspect.getframeinfo(inspect.currentframe()).lineno)
            wp = self.routeWaterPath()
            # Did we succeed in decreasing the number of segments?
            n1 = wp.numSegs()
            if n1 >= n0:
                raise UnusableWaterPath(self, lineNo=inspect.getframeinfo(inspect.currentframe()).lineno)
            assert(n1 < n0)
            # Number of segments has strictly decreased, so we continue.
            n0 = n1
        assert(wp.positive)
        return wp

class ContainedSegment:
    """
    Represents the relevant data for the portion of the goal segment contained
    within the face. Manages expansion of the face.
    """

    def __init__(self, basept, localGoalPt, globalGoalPt, wg):
        # coords (x, y) at beginning of goal segment:
        self.basept = basept
        # coords (x, y) at end of goal segment for routing:
        self.localGoalPt = localGoalPt
        # coords (x, y) at end of segment representing space needed by treebox:
        self.globalGoalPt = globalGoalPt
        self.formSegments()
        # the owning WaterGoal object:
        self.wg = wg
        # ideal edge length for the graph:
        self.iel = wg.iel
        # the TreePlacement object:
        self.tp = wg.tp
        # the dimension in which the generated sepcos are to operate:
        self.dim = wg.dim

    def formSegments(self):
        # segment representing space to be spanned by the route:
        self.localGoalSeg = LineSegment(self.basept, self.localGoalPt)
        # segment representing space needed by treebox:
        self.globalGoalSeg = LineSegment(self.basept, self.globalGoalPt)

    def getLength(self):
        return self.localGoalSeg.length

    def measureShortage(self):
        """
        :return: float, telling the "shortage", i.e. the extent to which the
                 global goal seg exceeds the local in length. Min 0.
        """
        return max(0, self.globalGoalSeg.length - self.localGoalSeg.length)

    def makeRoomForTreeNode(self, ps0):
        """
        :param ps0: an initial ProjSeq
        :return: nothing

        We attempt to extend the given ProjSeq so as to make room in the Face for
        the desired TreePlacement. If any of the projections is infeasible then
        we raise an UnusableWaterPath exception.
        """
        pcs = []
        # Get the root node of the TreePlacement
        root = self.tp.node
        # Sides
        # We can only work with obstacles that lie opposite the /local/ goal seg.
        sides = self.tp.face.getAllSidesOppositeSegment(self.localGoalSeg, openInterval=True)
        for side in sides:
            # If the root node lies on the Side, need no constraints.
            if side.containsNode(root): continue
            pt = side.getFirstPtOppositeSegment(self.localGoalSeg)
            sign = self.localGoalSeg.ptOnWhichSide(pt)
            assert(sign in [-1, 1])
            # We need the half-width of the Side opposite the longer of the two segments,
            # which is always the global goal seg.
            sideHW = side.halfwidthOppositeSegment(1 - sign, self.globalGoalSeg)
            someNode = side.firstNode()  # just need any Node on the Side
            left, right = (someNode, root) if sign == -1 else (root, someNode)
            w, h, u, v = self.tp.treeBoxWithRootVector(iel=self.iel)
            if self.globalGoalSeg.direc in Compass.vertical:
                gap = sideHW + w/2.0 + sign*u
            else:
                gap = sideHW + h/2.0 + sign*v
            gap = max(gap, 0)
            sepco = SepCo(self.dim, left, right, gap)
            pcs.append(sepco)
        # Treenodes
        alltps = self.tp.face.getAllTreePlacements()
        for tp1 in alltps:
            # Check whether the /unpadded/ treenode lies opposite the segment:
            pt = tp1.somePointOppositeSegment(self.localGoalSeg, iel=0, openInterval=True)
            if pt is not None:
                sign = self.localGoalSeg.ptOnWhichSide(pt)
                assert(sign in [-1, 1])
                # For computing the gap for the sepco, use the actual box node, which
                # /does/ include padding:
                tn = tp1.boxNode
                left, right = (tn, root) if sign == -1 else (root, tn)
                # And use the /padded/ version of the treenode that is to be added:
                w, h, u, v = self.tp.treeBoxWithRootVector(iel=self.iel)
                if self.globalGoalSeg.direc in Compass.vertical:
                    gap = tn.w/2.0 + w/2.0 + sign*u
                else:
                    gap = tn.h/2.0 + h/2.0 + sign*v
                gap = max(gap, 0)
                sepco = SepCo(self.dim, left, right, gap)
                pcs.append(sepco)
        ps0.addConstraintSet(pcs, self.dim)
        feasible = self.tp.face.applyPS(ps0, self.iel)
        if not feasible:
            raise UnusableWaterPath(self, lineNo=inspect.getframeinfo(inspect.currentframe()).lineno)


class WaterPath:

    def __init__(self, pts, wlev):
        """
        :param pts: list of (x, y) points
        :param wlev: the owning WaterLevel object
        """
        self.pts = pts
        self.wlev = wlev
        # Build segments
        self.segs = self.buildSegs(pts)
        # Compute directions
        self.forwards = Compass.cardinalDirection(wlev.basept, wlev.localGoalPt)
        self.backwards = Compass.flip(self.forwards)
        # The "summit" is the initial segment of the path which first reaches the
        # "height" of the local goal point.
        # (Apparently water flows uphill in this world...?)
        self.summit = self.computeFirstSummit()
        # The "ladder" is the list of segments that make the
        # upward edges of the summit.
        self.ladder = self.computeLadder(self.summit)
        # Compute boolean saying whether this path is "positive", meaning that there
        # are no backward segments on the path to first summit.
        self.positive = self.isMonotonicForward(self.summit)

    def buildSegs(self, pts):
        segs = []
        for i in range(len(pts) - 1):
            p, q = pts[i:i+2]
            segs.append(LineSegment(p, q))
        return segs

    def collapseOneSegment(self, ps0, iel):
        """
        :param ps0: an initial ProjSeq
        :param iel: ideal edge length for the graph
        :return: nothing

        This method should be called only if the path is not positive.
        In that case, we look for a path segment to collapse, trying to choose the best
        one, with the goal of making the path positive.
        If there is no collapsable segment, we raise an UnusableWaterPath exception.
        Otherwise we generate constraints to collapse the chosen segment, and project,
        raising an UnusuableWaterPath exception if the constraints are found to be
        infeasible.
        """
        assert(not self.positive)
        # Width for when we try to create "alleys" to route through:
        ALLEY_WIDTH = 10
        # Choose a segment.
        n = self.chooseBestSegmentToCollapse()
        # Try to collapse it.
        # Get the segment s to be collapsed, and the neighbouring segs r and t.
        r0, s0, t0 = self.segs[n-1: n+2]
        try:
            # In this try-block, any violated assertions will mean that
            # the path is unusable.
            # Choose the left and right nodes for the sepco.
            # First decide which of the neighbouring segs r and t is low and which is high.
            assert(r0.direc == t0.direc)
            rz, tz = r0.constCoord(), t0.constCoord()
            assert(rz != tz)
            low, high = (r0, t0) if rz < tz else (t0, r0)
            # Now we find all "left nodes" and all "right nodes."
            # The left nodes are all those which lie beside the high seg on its low side,
            # the right nodes are all those which lie beside the low seg on its high side.
            # Here we consider both treenodes and perimeter nodes, all at once.
            # Prepare a function to read the relevant coordinate of each node:
            coord = (lambda n: n.x) if r0.direc in Compass.vertical else (lambda n: n.y)
            # Compute the left nodes:
            nodes = self.wlev.tp.face.getAllTreenodesOppositeSegment(high)
            nodes.extend(self.wlev.tp.face.getAllPerimeterNodesOppositeSegment(high))
            lefts = filter(lambda n: coord(n) < high.constCoord(), nodes)
            # Compute the right nodes:
            nodes = self.wlev.tp.face.getAllTreenodesOppositeSegment(low)
            nodes.extend(self.wlev.tp.face.getAllPerimeterNodesOppositeSegment(low))
            rights = filter(lambda n: coord(n) > low.constCoord(), nodes)
            # Now build the sepcos and try applying them.
            # Prepare a function to read the relevant size from each node:
            size = (lambda n: n.w) if r0.direc in Compass.vertical else (lambda n: n.h)
            pcs = []
            for left in lefts:
                ls = size(left)/2.0
                for right in rights:
                    gap = ls + size(right)/2.0 + ALLEY_WIDTH
                    sepco = SepCo(s0.varDim, left, right, gap)
                    pcs.append(sepco)
            ps0.addConstraintSet(pcs, s0.varDim)
            feasible = self.wlev.tp.face.applyPS(ps0, iel)
            assert(feasible)
        except AssertionError:
            raise UnusableWaterPath(self.wlev, lineNo=inspect.getframeinfo(inspect.currentframe()).lineno)

    def chooseBestSegmentToCollapse(self):
        """
        :return: index n indicating the chosen segment, or raise UnusableWaterPath
                 if no collapsable segment exists.

                 When n is returned, it will be between 1 and N - 2 inclusive, where
                 N is the total number of segments in the path.
        """
        assert(not self.positive)
        N = len(self.segs)
        # To be collapsable, a segment must in particular have another segment
        # on each side of it. Therefore:
        if N < 3:
            raise UnusableWaterPath(self.wlev, lineNo=inspect.getframeinfo(inspect.currentframe()).lineno)
        assert(N >= 3)
        anyCollapsable = False
        # We'll call a segment "negative" if it is backwards AND belongs to the summit.
        anyNegativeAndCollapsable = False
        # Make a first pass, building data dictionaries about all the segments.
        data = []
        for n in range(1, N-1):
            r, s, t = self.segs[n-1:n+2]
            # s is Segment n
            # The previous and next segments are r and t, resp.
            # Segment s is collapsable iff segs r and t have the same direction.
            d = {
                'num': n,
                'negative': s.direc == self.backwards and n < len(self.summit),
                'collapsable': r.direc == t.direc,
                'seg': s
            }
            data.append(d)
            if d['collapsable']:
                anyCollapsable = True
                if d['negative']:
                    anyNegativeAndCollapsable = True
        # If none are collapsable (this happens if the path is a spiral), then
        # there is nothing we can do.
        if not anyCollapsable:
            raise UnusableWaterPath(self.wlev, lineNo=inspect.getframeinfo(inspect.currentframe()).lineno)
        # One or more segments is collapsable, so we will choose one of those.
        n0 = -1
        # If any of these is negative, then we will choose from among those.
        if anyNegativeAndCollapsable:
            # Filter out the segs that aren't negative and collapsable.
            data = filter(lambda d: d['negative'] and d['collapsable'], data)
            # And choose a longest one.
            n0 = max(data, key=lambda d: d['seg'].length)['num']
        else:
            # In this case there are collapsable segments, but none of them is
            # a negative segment. We choose one that is /closest/ to a negative one
            # in the sequence of segments.
            # First compute the distance from each non-negative segment to the nearest
            # negative one to its /left/, using N as effectively infinity if there is
            # none to the left.
            last = -1
            for d in data:
                if d['negative']:
                    last = d['num']
                else:
                    distance = d['num'] - last if last >= 0 else N
                    d['left'] = distance
            # Now compute the distance from each non-negative segment to the nearest
            # negative one to its /right/, using N as effectively infinity if there is
            # none to the right.
            last = -1
            for d in reversed(data):
                if d['negative']:
                    last = d['num']
                else:
                    distance = last - d['num'] if last >= 0 else N
                    d['right'] = distance
            # Now throw away the non-collapsable segments.
            data = filter(lambda d: d['collapsable'], data)
            # And choose one that was closest to one of the negative segments.
            n0 = min(data, key=lambda d: min(d['left'], d['right']))['num']
        assert(1 <= n0 and n0 <= N - 2)
        return n0

    def numSegs(self):
        ":return: number of segments in this path"
        return len(self.segs)

    def computeLadder(self, segs):
        rungs = []
        for seg in segs:
            if seg.direc == self.forwards:
                rungs.append(seg)
        return rungs

    def ptOnWhichSide(self, pt):
        """
        :param pt: a point (x, y)
        :return: If the pt is covered by the interval of one of the rungs of the
                 ladder, then you will get -1 or 1 indicating that it lies on the
                 low or high side of this path, or 0 if it lies directly on the
                 path. You will get None otherwise.
        """
        rungs = self.ladder
        side = None
        x, y = pt
        w, z = (y, x) if self.forwards in Compass.vertical else (x, y)
        for rung in rungs:
            if rung.closedIntervalIncludesCoord(w):
                side = rung.coordOnWhichSide(z)
                break
        return side

    def computeFirstSummit(self):
        bx, by = self.wlev.basept
        gx, gy = self.wlev.localGoalPt
        if bx == gx:
            reachesHeight = (lambda p: p[1] >= gy) if gy > by else (lambda p: p[1] <= gy)
        else:
            reachesHeight = (lambda p: p[0] >= gx) if gx > bx else (lambda p: p[0] <= gx)
        segs = self.segs
        summit = []
        for seg in segs:
            summit.append(seg)
            if reachesHeight(seg.p1): break
        else:
            # If we didn't break that means the path somehow didn't actually reach its goal.
            raise Exception("Path does not reach local goal point!")
        return summit

    def isMonotonicForward(self, segs):
        """
        :param segs: list of segments
        :return: boolean saying if this path is monotonic forward, i.e. never
                 goes in the backward direction
        """
        ans = True
        for seg in segs:
            if seg.direc == self.backwards:
                ans = False
                break
        return ans
